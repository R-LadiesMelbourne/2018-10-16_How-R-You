---
title: "How R you? - R-Ladies Melbourne code and tips!"
date: "01/10/2018"
always_allow_html: yes
output:
  github_document:
    toc: yes
    toc_depth: 3
  html_document:
    theme: cosmo
    toc: yes
    toc_depth: 3
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message=FALSE,warning=FALSE)

library(magick)
library(png)
library(grid)
library(emo)
library(icon)
```


```{r echo=FALSE,message=FALSE,fig.width=2,fig.height=2,fig.align='center',cache=TRUE}
library(png)
library(grid)
img <- readPNG("./Figures/logo.png")
grid.raster(img)
```

# Violin plots with overlayed boxplots and coloured by group

**Author**: [Anna Quaglieri](https://github.com/annaquaglieri16)

Whenever I have to display to compare continuous variables this has become my favourite way to go! *Violin plot* + *boxplot* allows me to see both the quantiles and the overall density distribution that if can often be missed with only boxplots.

```{r}
library(ggplot2)

data <- data.frame(Gene = rep(c("Gene1","Gene2","Gene3","Gene4"),each=46),
                   Counts = log2(rbinom(n = 46*4,size = 1000,prob = 0.3)),
                   CBF = sample(x = c("A","B"),size = 46*4,replace=TRUE))

dodge <- position_dodge(width = 1)
ggplot(data,aes(x=Gene,y=Counts,fill=CBF)) + theme_bw()  + theme(axis.text.x = element_text(angle = 0)) + geom_violin(trim=FALSE,position = dodge) + geom_boxplot(width=.1,position = dodge,show.legend = FALSE) +  labs(y="log2Counts") + facet_wrap(~Gene,scales="free_x")
```


# Matching strings

**Author**: [Saskia Freytag](https://github.com/SaskiaFreytag)

Find Saskia's fabulous slides about all the ways to match strings in R [here](https://matchingstrings.netlify.com/#1). 

```{r echo=FALSE,message=FALSE,fig.width=3,fig.height=3,fig.align='center',cache=TRUE}
library(png)
library(grid)
img <- readPNG("./How_R_You_R-LadiesMelbourne_code_and_tips_data/saskia.png")
grid.raster(img)
```

# DT package for interactive tables

```{r }
library(DT)
library(reshape2) # to get the "tips" dataset

data("tips")

datatable(tips, filter = "top", options = list(pageLength = 8))  %>%   ## Bold some numbers:
  formatStyle('total_bill', 
    fontWeight = styleInterval(18, c('normal', 'bold'))) %>%  ## show colour bar
  formatStyle('tip', 
    background = styleColorBar(tips$tip, 'mediumpurple'),
    backgroundSize = '100% 95%',
    backgroundRepeat = 'no-repeat',
    backgroundPosition = 'centre') %>%   ## transform values
  formatStyle('sex', 
    transform = 'rotateX(-45deg) rotateY(-30deg) rotateZ(-50deg)',
    backgroundColor = styleEqual(unique(tips$sex), c('lightblue', 'lightseagreen'))) %>%  ## colour value/background
  formatStyle('size', 
    color = styleInterval(c(2, 4), c('blue', 'black', 'red')), 
    backgroundColor = styleInterval(c(2, 4), c('white', 'gray', 'gray50')))
```



# Using `pheatmap` to visualise the structure of your data 

**Author**: [Anna Quaglieri](https://github.com/annaquaglieri16)

I am doing my PhD in Bioinformatics and in particular I work with gene expression data from Leukemia patients belonging to several Australian clinical trials. Patients data tends to arrive in several batches since patient's genes are sequenced usually at different times. Sample also come in replicates (same sample processed twice). Even though every patient will have a lot of genes, my datasets are never too big in terms of the number of patients. When I had my first dataset, to help me reasoning and to always have the chance to look at a summarised structure of my data I came up with a way to put an excel spreadsheet with patients' information and replicates into an image with an `heatmap`. I realised that also my collaborators found this really useful and they usually have always at hand the image of the structure of the data whenever we meet. Of course, this method is not really feasable with datasets that have many samples but for me it has never been the case!

**Example data**

Below I provided a sample `excel` spreadhseet `DatasetStructure.xlsx` with a fake dataset and the script that I would use to visualise it. Of course, every patients can have many many more variables and I try to choose the most relevant ones to revent the visualisation from becoming a real mess of colours and labels (which sometimes it does anyway!)! 

In the example below I want to visualise the structure of a dataset constituted by 38 patients with disease `A` or `B` for which samples were collected at 3 different time points (`Time0`, `Time1` and `Time2`). 

* Every patient (`Patient` column) has different samples extracted at different time points that I called `Time0`, `Time1` and `Time2` 
* Samples were extracted across two different batches one year apart from each other: `Batch1` and `Batch2`
* There can be replicated samples (the same sample processed twice or more) within or between each batch
* Patients can have one out of two disease types: `A` or `B`

```{r}
library(tidyverse)
library(readxl)
library(pheatmap)

patients_infos <- read_excel(file.path("How_R_You_R-LadiesMelbourne_code_and_tips_data/DatasetStructure.xlsx")) 
head(patients_infos)
```


1. **Define replicates within a batch**: two samples are replicate of each other if they belong to the same `Patient` and they were collected at the same `Time`. 

```{r}
patients_infos <- patients_infos %>%
  unite(Repl.Within, Patient, Time, sep = ".",remove=FALSE)
head(patients_infos)
```

2. Take unique combinations of the variables that I want to display in the structure of the data

```{r}
reduced_infos <- patients_infos %>%
  group_by(Patient,DiseaseType,Time,Batch) %>% 
  summarise(Nsam=length(Repl.Within)) 
head(reduced_infos)
```

3. Create variable used to spread the dataset from long to wide

```{r}
reduced_infos <- reduced_infos %>%
  unite(Time.Batch, Time, Batch,sep=".")

infos_wide <- reduced_infos %>% spread(key = Time.Batch,value = Nsam)
length(unique(reduced_infos$Patient))
```

4. Set to NA if there are no samples available for a patient at one time point

```{r}
infos_wide[is.na(infos_wide)] <- 0 
```


5. The function `pheatmap()` wants a matrix as input to be displayed. The matrix needs rownames. At the moment `infos_wide` is a `tibble()` which does not allow roenames. I first `data.frame()` and when it is time to plot it I will only provide as input to `pheatmap()` numeric values.


```{r}
infos_wide <- data.frame(infos_wide)
rownames(infos_wide) <- infos_wide$Patient
```

6. Set snnotation for columns (time points) and rows (patients) 

```{r}
ann_columns <- data.frame(Batch=c("Batch1","Batch2",
                                    "Batch1","Batch2",
                                    "Batch1","Batch2"),
                           Time=c("Time0","Time0",
                                  "Time1","Time1",
                                  "Time2","Time2"))

ann_colors_wide <- list(Batch=c(Batch1 = "#762a83", Batch2 = "#1b7837"),
                        Time=c(Time0="#662506",Time1="#993404",Time2="#ec7014"),
                        DiseaseType = c(A="#78c679",B="#f7fcb9"))

rownames(ann_columns) <- colnames(infos_wide)[-c(1:2)]

# Row annotation
infos_wide$DiseaseType <- factor(infos_wide$DiseaseType,levels=c("A","B"),ordered = TRUE)
infos_wide <- infos_wide[order(infos_wide$DiseaseType),]
infos_wide$order <- 1:nrow(infos_wide)
infos_wide$order <- factor(infos_wide$order ,levels=infos_wide$order ,labels=infos_wide$Patient)

annotation_row <- data.frame(DiseaseType = infos_wide$DiseaseType)
rownames(annotation_row) <- infos_wide$order
```

These are the final elements that you need to plot the structure:

* The matrix indicating how many replicates are at each time point for each patient

```{r}
head(infos_wide[order(infos_wide$DiseaseType),-c(1,2,ncol(infos_wide))])
```

* The annotation for the rows

```{r}
head(annotation_row)
```

* The annotation for the columns

```{r}
head(annotation_row)
```

* The colours for both annotation

```{r}
ann_colors_wide
```


## See the final result!

```{r fig.width=11,fig.height=8,fig.align='center'}
pheatmap(infos_wide[order(infos_wide$DiseaseType),-c(1,2,ncol(infos_wide))],
         main = "Data Structure",
         cluster_cols=FALSE,cluster_rows=FALSE,
         annotation_col = ann_columns,
         annotation_row = annotation_row,
         annotation_colors = ann_colors_wide,
        breaks=c(0,0.9,1.9,2.9,3.9,4.9),col=c("#f1eef6","#74a9cf","#0570b0","blue","dark blue","black","grey"),show_colnames = FALSE,
        width = 11,height = 10)
```


## Useful links to know more about heatmaps in R

* http://www.sthda.com/english/articles/28-hierarchical-clustering-essentials/93-heatmap-static-and-interactive-absolute-guide/
* http://www.bioconductor.org/packages/release/bioc/vignettes/ComplexHeatmap/inst/doc/s4.heatmap_annotation.html


# Different ways of plotting your data with `ggplot` using `geom_histogram` and `geom_density_ridges`

**Authors**: Marie Trussart

I used here ggd, which is a data frame extracted from clustering and expression datasets and that's how I define it:

`ggd <- melt(data.frame(cluster = cell_clustering, expr),id.vars = "cluster", value.name = "expression")`


```{r eval=FALSE}
### Density distributions
ggplot() +
geom_density_ridges(data = ggd, aes(x = expression, y = cluster), alpha = 0.3) +  scale_x_continuous(expand = c(0.01, 0)) +
scale_y_discrete(expand = c(0.01, 0))+
theme_ridges() +
theme(axis.text = element_text(size = 7),
strip.text = element_text(size = 7))
ggsave("Fig1.pdf")

## Histogram distribution by facet
ggplot(data = ggd, aes(x = expression)) + facet_wrap(~cluster, scales = 'free_y') +
geom_histogram()+
theme(strip.text.x = element_text(size=6),
        strip.text.y = element_text(size=6),
        axis.text = element_text( size = 8 ),
        axis.text.x = element_text( size = 8 ),
        axis.title = element_text( size = 8, face = "bold"))
ggsave("Fig2.pdf")

### All the histogram distributions on the same plot
ggplot(data =  ggd[grep("DG19", ggd$cluster),], aes(x = expression,fill=cluster))  +
geom_histogram()
ggsave("Fig3.pdf")
```


```{r echo=FALSE,message=FALSE,fig.width=5,fig.height=5,fig.align='center',cache=TRUE, fig.cap="Figure 1. `geom_density_ridges()`"}
img <- readPNG("./How_R_You_R-LadiesMelbourne_code_and_tips_data/MarieTrussart_Fig1.png")
grid.raster(img)
```

```{r echo=FALSE,message=FALSE,fig.width=5,fig.height=5,fig.align='center',cache=TRUE, fig.cap="Figure 2. `geom_histogram() and `facet_wrap()``"}
img <- readPNG("./How_R_You_R-LadiesMelbourne_code_and_tips_data/MarieTrussart_Fig2.png")
grid.raster(img)
```

```{r echo=FALSE,message=FALSE,fig.width=5,fig.height=5,fig.align='center',cache=TRUE, fig.cap="Figure 3. Another example of `geom_histogram() colouring by classes.`"}
img <- readPNG("./How_R_You_R-LadiesMelbourne_code_and_tips_data/MarieTrussart_Fig3.png")
grid.raster(img)
```

# Data visualisation via volcano plots

As a wet-lab immunologist, most of my job involves trying to **find** and then **illustrate** meaningful patterns from large biological datasets.  

We obtain **a lot** of data from RNA sequencing experiments. These are experiments which look at how many mRNA molecules (i.e. message signals) are found in an object and how these signals differ in quantity across multiple objects.  

We often analyse datasets with changes across >10,000 signals between >=2 different objects. A [volcano plot](https://en.wikipedia.org/wiki/Volcano_plot_(statistics)) is one way we visualise all statistically significant versus non-significant differences in one graph.  

## A typical data analysis pipeline

1. A large matrix is obtained, containing the number of signals 'counted' per signal type per object. Each row contains a unique signal ID (i.e. in my case a unique gene ID) and each column contains all the signal counts for one single object. *The researcher also has additional information about each object (i.e. object classification categories like object type, timepoint, batch etc.). This is very important for downstream RNAseq analysis, but not required for this analysis.* 

2. A minimal information threshold is set (i.e. minimal signal count per signal > 1 for at least 1 object). **An awesome statistical package**, in my case `DESeq2` (https://bioconductor.org/packages/release/bioc/html/DESeq2.html), is then used to test whether any signals are differentially expressed between different objects. 

3. **Data visualisation** of all statistically **significant** versus **non-significant** signals between at least two objects, with the aim of highlighting any new or particularly interesting biological patterns.


Here, a **volcano plot** is used to depict:

* how many signals are differentially expressed (using a statistical cut-off),
* **and** by how much (i.e. signal fold change),
* between two objects tested.  


## Drawing volcano plots with `ggplot2`

A **results output file** can be created in `DESeq2` i.e. using `results(dds, contrast=c("Sample.type", "A", "B"))` and converted into a dataframe. 

For convenience, I have provided a fake results output called `AvsB_results.csv` for use (i.e. a dataframe containing all signal differences between object A versus object B). Since we will be using both `dplyr` and `ggplot2`, I always find it more convenient to download the `tidyverse` package.    

```{r }
library("tidyverse")
library("ggrepel") # We will also need this package for the final labelling of data points. 
```

We start with our dataset of interest. 

Note that for the volcano plot, you only need **three** columns of information:

1. Gene symbol (aka unique signal ID)
2. Log2(fold change) (aka how much the level of each signal in A differs from B by)
3. Padj (the adjusted P-value or statistical likelihood for whether a signal in A is not different to that of B)

```{r}
AvsB_results <- read.csv("How_R_You_R-LadiesMelbourne_code_and_tips_data/AvsB_results.csv", header = T, stringsAsFactors = F)
str(AvsB_results) # The dataframe contains the 3 columns of info described above. 
```

A simple volcano plot depicts:  

* Along its x-axis: log2(fold change) 
* Along its y-axis: -log10(padj) 

Note that the y-axis is depicted as -log10(padj), which allows the data points (i.e. volcano spray) to project upwards as the absolute value along the x axis increases. Graphically, this is more intuitive to visualise.

```{r}

simple_vp <- ggplot(AvsB_results, aes(x = log2FoldChange,
                         y = -log10(padj))) + 
  geom_point() # A simple volcano plot is created.

simple_vp

```

This plot is too plain as objects of interest do not easily jump out at us.  
A good volcano plot will highlight all the signals (represented by individual data points) which are significantly different between A vs B.  
In this case, we would be interested in highlighting genes which have a **padj <= 0.05 (or a -log10(padj) >= 1.30103)** (my chosen statitical cut-off). I would also be interested in highlighting genes which additionally have a log2 fold change <= -1 or >= 1 (i.e. signals which are at least 2-fold bigger or smaller in A vs B). 

I can now define these quandrants using:

```{r}

simple_vp + 
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") + # horiztonal dashed line
  geom_vline(xintercept = c(-1,1), linetype = "dashed") # vertical dashed line

```

The top-left quadrant contains all signals that are significantly decreased in A vs B, and the top right quandrant contains genes that are significantly increased in A vs B. The remaining genes are not significantly different and hence much less interesting to me.  

The next thing we can therefore do is to **highlight** these three different groups of signals.   
To do this, I return to my original dataframe and use the `dplyr::mutate` function.  

```{r}

AvsB_results <- mutate(AvsB_results,
                       AvsB_type = ifelse(is.na(padj)|padj > 0.05|abs(log2FoldChange) < 1, "ns", 
                         ifelse(log2FoldChange <= -1, "down",
                                "up"))) # creates a new column called AvsB_type, with signals classified as "ns", "down" or "up"

group_by(AvsB_results, AvsB_type) %>%
  summarize(Counts = n()) # counts how many signals are present in each category

```

Now that AvsB_type can segregate each signal based on whether it is 'up', 'down' or 'ns' (i.e. non-significant), I can colour these three signal types differently (and/or change their size/transparency to make different points stand out more versus less). 

```{r}

cols <- c("up" = "#ffad73", "down" = "#26b3ff", "ns" = "grey") 
sizes <- c("up" = 3, "down" = 3, "ns" = 1) 
alphas <- c("up" = 1, "down" = 1, "ns" = 0.5)

ggplot(AvsB_results, aes(x = log2FoldChange,
                         y = -log10(padj))) +
  geom_point(aes(colour = AvsB_type, #specify point colour by AvsB_type
                 size = AvsB_type, #specify point size by AvsB_type
                 alpha = AvsB_type)) + #specify point transparency by AvsB_type
  scale_color_manual(values = cols) +
  scale_size_manual(values = sizes) +
  scale_alpha_manual(values = alphas) +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") + 
  geom_vline(xintercept = c(-1,1), linetype = "dashed") 
  
```

This is great! But there is still one final nifty trick!  

As a biologist, I often get >100s of genes which are significantly increased or decreased between two objects. To examine whether **interesting patterns (interconnected signals)** exist within these 100 genes, I run them through gene over-representation databases like [this one](http://software.broadinstitute.org/gsea/msigdb/index.jsp). 


```{r}

Interesting_pathway <- c("Nemf", "Rft1", "Atp5h") # An external database identifies an interesting signal network!

```

We would like to highlight these particular signals, by representing them in a different (darker) colour and also by labelling each individual point of interest. 

```{r}
ggplot(AvsB_results, aes(x = log2FoldChange,
                         y = -log10(padj))) +
  geom_point(aes(colour = AvsB_type,
                 size = AvsB_type,
                 alpha = AvsB_type)) +
  scale_color_manual(values = cols) +
  scale_size_manual(values = sizes) +
  scale_alpha_manual(values = alphas) +
  scale_x_continuous(limits = c(-4, 4)) + # changing the x-axis to make my volcano plot symmetrical
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") + 
  geom_vline(xintercept = c(-1,1), linetype = "dashed") +
  geom_text_repel(data = AvsB_results %>% 
                    filter(Symbol %in% Interesting_pathway), # labels only genes in the interesting pathway
                  aes(label = Symbol),
                  size = 3.5,
                  color = "black",
                  nudge_x = 0.3, nudge_y = 0.1) + 
  geom_point(data = AvsB_results %>%
               filter(Symbol %in% Interesting_pathway), # adds new points for only genes in the interesting pathway
             color = "#d91933",
             size = 2) +
  theme_classic() + # creates a white background
  theme(panel.border = element_rect(colour = "black", fill=NA, size= 0.5)) # creates a plot border

```

Viola! Enjoy your volcano plot (and remember, there are lots of graphical modifiers you can use to visualise data using them, as long as your methods are logical and reasonable)! 

## **Development notes**  
**Chuanxin Liu** devised the elegant strategy for labelling all signal types as 'up', 'ns' or 'down' and the code for the labelling of specific signal data points.

## **Other resources**  
http://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html

http://www.sthda.com/english/wiki/ggplot2-texts-add-text-annotations-to-a-graph-in-r-software

http://www.sthda.com/english/wiki/ggplot2-axis-scales-and-transformations#change-x-and-y-axis-limits

# Where to get help with your `R` question?

"Imagine you have an `R` question..." Check out MaÃ«lle super comprehensive blog post [Where to get help with your `R` question?](https://masalmon.eu/2018/07/22/wheretogethelp/) about how to make your search the most efficient and targeted possible!  

# How to get all the functions within a package

**Author**: [Emi Tanaka](http://github.com/emitanaka)

Below you can find all the functions in `dplyr` (minus the internal hidden ones). There are in total `r length(ls("package:dplyr"))` functions in `dplyr`. 

```{r, message=F, warning=F}
library(dplyr)
ls("package:dplyr")
```

# Session Infos

```{r}
sessionInfo()
```



